# Arbitrage Pricing Theory (APT)

## 1. Concept Skeleton
**Definition:** Multi-factor asset pricing model where returns driven by multiple systematic risk factors; linear factor structure  
**Purpose:** Generalize CAPM without restrictive assumptions; identify systematic risk sources; arbitrage-based pricing  
**Prerequisites:** CAPM, factor analysis, arbitrage concept, linear algebra, diversification

## 2. Comparative Framing
| Model | CAPM | APT | Fama-French 3F | Statistical Factor Models |
|-------|------|-----|---------------|---------------------------|
| **Factors** | 1 (market) | k unspecified | 3 specified (Mkt, SMB, HML) | Principal components |
| **Theory** | Equilibrium (utility) | Arbitrage (no-arbitrage) | Empirical factors | Pure statistical |
| **Assumptions** | Strong (homogeneous, M-V utility) | Weak (no arbitrage) | Empirical observation | None (data-driven) |
| **Factor Identity** | Market portfolio | Unspecified macro factors | Size, value premiums | Latent factors |
| **Testability** | High (specific predictions) | Low (factors not specified) | High (factors observable) | Medium |

## 3. Examples + Counterexamples

**Simple APT Example:**  
Return driven by 3 factors: GDP growth, inflation, interest rates  
Ri = 5% + 1.2·GDP + (-0.8)·Inflation + (-1.5)·IntRate + εi  
Asset sensitive to growth, hurt by inflation and rising rates

**Arbitrage Opportunity:**  
Portfolio A: E[R] = 12%, β₁ = 1.0, β₂ = 0.5  
Portfolio B: E[R] = 10%, β₁ = 1.0, β₂ = 0.5  
Same factor exposures, different returns → arbitrage (long A, short B)

**Failure Case:**  
Factor specification: Choose wrong factors (e.g., ignore tech disruption factor in 2020)  
Model misspecified → poor predictions, unexplained returns

## 4. Layer Breakdown
```
Arbitrage Pricing Theory Framework:
├─ Fundamental Equation:
│   ├─ Ri = E[Ri] + βi1·F1 + βi2·F2 + ... + βik·Fk + εi
│   ├─ Ri: Return on asset i
│   ├─ E[Ri]: Expected return (determined by factor exposures)
│   ├─ Fj: Factor j realization (surprise component, mean = 0)
│   ├─ βij: Loading (sensitivity) of asset i to factor j
│   ├─ εi: Idiosyncratic error (diversifiable, uncorrelated with factors)
│   └─ k: Number of systematic factors (unspecified by theory)
├─ Key Assumptions:
│   ├─ Factor Structure: Returns generated by common factors + idiosyncratic shocks
│   ├─ Well-Diversified Portfolios: εi → 0 as n → ∞ (idiosyncratic risk eliminates)
│   ├─ No Arbitrage: Cannot earn riskless profit with zero net investment
│   ├─ Homogeneous Beliefs: Investors agree on factor model (not on preferences)
│   └─ Fewer Assumptions than CAPM: No market portfolio, no M-V utility required
├─ Pricing Relationship (No-Arbitrage Condition):
│   ├─ E[Ri] = rf + βi1·λ1 + βi2·λ2 + ... + βik·λk
│   ├─ rf: Risk-free rate
│   ├─ λj: Risk premium (price) for factor j
│   ├─ βij·λj: Compensation for exposure to factor j
│   └─ Derived from: No arbitrage among well-diversified portfolios
├─ Arbitrage Intuition:
│   ├─ Suppose two portfolios A, B with same factor exposures (β)
│   ├─ If E[RA] > E[RB], arbitrage exists:
│   │   ├─ Long portfolio A (high expected return)
│   │   ├─ Short portfolio B (same risk, lower return)
│   │   ├─ Zero net investment, zero systematic risk
│   │   └─ Positive expected profit (arbitrage)
│   ├─ Arbitrage forces: Prices adjust until E[RA] = E[RB]
│   └─ Result: Expected return determined solely by factor loadings
├─ Factor Selection (Practical Implementation):
│   ├─ Macroeconomic Factors:
│   │   ├─ GDP growth rate
│   │   ├─ Inflation (CPI, PPI)
│   │   ├─ Interest rates (yield curve, term spread)
│   │   ├─ Exchange rates (currency risk)
│   │   ├─ Oil prices (commodity risk)
│   │   └─ Default spread (credit risk)
│   ├─ Statistical Factors:
│   │   ├─ Principal Component Analysis (PCA) on returns
│   │   ├─ Extract latent factors explaining covariance
│   │   ├─ Factor 1 (PC1): Often market-like (explains most variance)
│   │   └─ Subsequent factors: Orthogonal sources of risk
│   ├─ Fundamental Factors (Fama-French approach):
│   │   ├─ Firm characteristics: Size, value, momentum, profitability
│   │   ├─ Construct factor-mimicking portfolios
│   │   └─ Empirically motivated factor choice
│   └─ Theory Silent: APT doesn't specify which factors (flexibility and weakness)
├─ Estimation Process:
│   ├─ Step 1: Identify Factors
│   │   ├─ Economic theory (macro variables)
│   │   ├─ Statistical methods (PCA, factor analysis)
│   │   └─ Prior research (established factors)
│   ├─ Step 2: Time Series Regression (for each asset)
│   │   ├─ Ri,t = αi + βi1·F1,t + βi2·F2,t + ... + εi,t
│   │   ├─ Estimate factor loadings βij
│   │   └─ Should find αi ≈ 0 if model correct
│   ├─ Step 3: Cross-Sectional Regression
│   │   ├─ E[Ri] = λ0 + βi1·λ1 + βi2·λ2 + ...
│   │   ├─ Estimate risk premiums λj
│   │   └─ Test: λ0 = rf (intercept should be risk-free rate)
│   └─ Step 4: Validate
│       ├─ Check R² (explanatory power)
│       ├─ Test residuals for patterns
│       └─ Out-of-sample prediction tests
├─ APT vs CAPM:
│   ├─ Assumptions: APT weaker (no utility, no market portfolio)
│   ├─ Factors: CAPM = 1 (market), APT = k (multiple sources of risk)
│   ├─ Derivation: CAPM equilibrium, APT arbitrage
│   ├─ Empirics: APT more flexible, better fits
│   ├─ Testability: CAPM more testable (specific), APT ambiguous (which factors?)
│   └─ Practical Use: CAPM simpler, APT more realistic but requires factor choice
├─ Applications:
│   ├─ Risk Decomposition: Attribute returns to specific risk factors
│   ├─ Portfolio Construction: Target exposures to desired factors
│   ├─ Risk Management: Hedge specific factor exposures
│   ├─ Performance Evaluation: Multi-factor alpha (residual after factor adjustment)
│   ├─ Asset Allocation: Diversify across factor exposures
│   └─ Expected Return Forecasting: E[Ri] based on factor risk premiums
├─ Empirical Evidence:
│   ├─ Chen, Roll, Ross (1986): 5 macro factors explain stock returns
│   │   ├─ Industrial production growth
│   │   ├─ Inflation (expected and unexpected)
│   │   ├─ Term spread (long-short rate)
│   │   ├─ Default spread (Baa-Aaa)
│   │   └─ Market factor
│   ├─ Factor premiums vary over time (time-varying risk prices)
│   ├─ R² improvement over CAPM: Moderate (~5-15%)
│   └─ Fama-French factors often outperform macro factors empirically
└─ Limitations & Critiques:
    ├─ Factor Ambiguity: Theory doesn't specify factors (practitioners must choose)
    ├─ Data Mining: Risk of selecting factors that worked historically
    ├─ Factor Instability: Risk premiums change over time (non-stationarity)
    ├─ Number of Factors: How many k? Trade-off between fit and overfitting
    ├─ Measurement Error: Macro factors measured with noise
    ├─ Testability: Hard to reject (can always add more factors)
    ├─ Idiosyncratic Risk: Assumes perfect diversification (realistic for large portfolios only)
    └─ Behavioral Factors: APT assumes arbitrage works (limits to arbitrage in practice)
```

**Interaction:** Multi-factor linear model prices assets through no-arbitrage condition on factor exposures

## 5. Mini-Project
Implement APT using macroeconomic factors and PCA-derived factors:
```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime, timedelta
import statsmodels.api as sm
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from fredapi import Fred
import warnings
warnings.filterwarnings('ignore')

# Note: You'll need FRED API key for macro data
# Sign up free at: https://fred.stlouisfed.org/docs/api/api_key.html
FRED_API_KEY = 'your_api_key_here'  # Replace with your key

# Download asset data
tickers = ['SPY', 'QQQ', 'IWM', 'EFA', 'EEM', 'TLT', 'GLD', 'XLE', 'XLF', 'XLK', 'XLV', 'XLI']
end_date = datetime.now()
start_date = datetime(2010, 1, 1)

print("Downloading asset data...")
data = yf.download(tickers, start=start_date, end=end_date, progress=False)['Adj Close']
returns = data.pct_change().dropna()

# For demonstration, we'll create synthetic macro factors
# In practice, download from FRED API
print("\nCreating synthetic macro factors (replace with actual data in production)...")

# Generate synthetic macro factor surprises (mean 0)
np.random.seed(42)
n_periods = len(returns)

macro_factors = pd.DataFrame({
    'GDP_surprise': np.random.normal(0, 0.01, n_periods),
    'Inflation_surprise': np.random.normal(0, 0.005, n_periods),
    'IntRate_surprise': np.random.normal(0, 0.003, n_periods),
    'Credit_spread': np.random.normal(0, 0.002, n_periods),
    'VIX_change': np.random.normal(0, 0.05, n_periods)
}, index=returns.index)

# Add some realistic correlation with returns
# Market correlation with macro factors
market_ret = returns['SPY']
macro_factors['GDP_surprise'] = 0.3 * market_ret + 0.7 * macro_factors['GDP_surprise']
macro_factors['Inflation_surprise'] = -0.2 * market_ret + 0.8 * macro_factors['Inflation_surprise']
macro_factors['IntRate_surprise'] = -0.25 * market_ret + 0.75 * macro_factors['IntRate_surprise']

def apt_regression_macro(asset_returns, factor_data):
    """
    Run APT regression using macroeconomic factors
    """
    # Align dates
    common_dates = asset_returns.index.intersection(factor_data.index)
    y = asset_returns.loc[common_dates]
    X = factor_data.loc[common_dates]
    
    # Add constant
    X_with_const = sm.add_constant(X)
    
    # OLS regression
    model = sm.OLS(y, X_with_const)
    results = model.fit()
    
    # Robust standard errors
    results_robust = model.fit(cov_type='HAC', cov_kwds={'maxlags': 3})
    
    factor_loadings = results.params[1:]  # Exclude constant
    
    return {
        'alpha': results.params['const'],
        'loadings': factor_loadings,
        'tvalues': results_robust.tvalues[1:],
        'pvalues': results_robust.pvalues[1:],
        'rsquared': results.rsquared,
        'residuals': results.resid,
        'results': results_robust
    }

def extract_statistical_factors(returns_data, n_factors=5):
    """
    Extract statistical factors using PCA
    """
    # Standardize returns
    scaler = StandardScaler()
    returns_scaled = scaler.fit_transform(returns_data)
    
    # PCA
    pca = PCA(n_components=n_factors)
    factors = pca.fit_transform(returns_scaled)
    
    # Create DataFrame
    factor_df = pd.DataFrame(
        factors,
        index=returns_data.index,
        columns=[f'PC{i+1}' for i in range(n_factors)]
    )
    
    return factor_df, pca

def apt_regression_statistical(asset_returns, statistical_factors):
    """
    Run APT regression using statistical (PCA) factors
    """
    common_dates = asset_returns.index.intersection(statistical_factors.index)
    y = asset_returns.loc[common_dates]
    X = statistical_factors.loc[common_dates]
    
    X_with_const = sm.add_constant(X)
    
    model = sm.OLS(y, X_with_const)
    results = model.fit(cov_type='HAC', cov_kwds={'maxlags': 3})
    
    return {
        'alpha': results.params['const'],
        'loadings': results.params[1:],
        'tvalues': results.tvalues[1:],
        'rsquared': results.rsquared,
        'results': results
    }

# Extract statistical factors (PCA)
print("\nExtracting statistical factors using PCA...")
stat_factors, pca_model = extract_statistical_factors(returns, n_factors=5)

# Explained variance by each principal component
print("\n" + "="*100)
print("PRINCIPAL COMPONENT ANALYSIS")
print("="*100)
variance_explained = pd.DataFrame({
    'Component': [f'PC{i+1}' for i in range(5)],
    'Variance Explained (%)': pca_model.explained_variance_ratio_ * 100,
    'Cumulative (%)': np.cumsum(pca_model.explained_variance_ratio_) * 100
})
print(variance_explained.round(2).to_string(index=False))

# Run APT regressions - Macro factors
print("\nRunning APT regressions with macro factors...")
apt_macro_results = {}
for ticker in tickers:
    apt_macro_results[ticker] = apt_regression_macro(returns[ticker], macro_factors)

# Run APT regressions - Statistical factors
print("Running APT regressions with statistical factors...")
apt_stat_results = {}
for ticker in tickers:
    apt_stat_results[ticker] = apt_regression_statistical(returns[ticker], stat_factors)

# CAPM for comparison
def capm_regression(asset_returns, market_returns):
    """
    Simple CAPM regression
    """
    common_dates = asset_returns.index.intersection(market_returns.index)
    y = asset_returns.loc[common_dates]
    X = sm.add_constant(market_returns.loc[common_dates])
    
    model = sm.OLS(y, X)
    results = model.fit(cov_type='HAC', cov_kwds={'maxlags': 3})
    
    return {
        'alpha': results.params['const'],
        'beta': results.params.iloc[1],
        'rsquared': results.rsquared
    }

print("Running CAPM regressions for comparison...")
capm_results = {}
for ticker in tickers:
    if ticker != 'SPY':
        capm_results[ticker] = capm_regression(returns[ticker], returns['SPY'])

# Comparison table
comparison_data = []
for ticker in tickers:
    if ticker == 'SPY':
        continue
    
    capm = capm_results[ticker]
    apt_m = apt_macro_results[ticker]
    apt_s = apt_stat_results[ticker]
    
    comparison_data.append({
        'Ticker': ticker,
        'CAPM Alpha (%)': capm['alpha'] * 12 * 100,
        'CAPM Beta': capm['beta'],
        'CAPM R²': capm['rsquared'],
        'APT-Macro Alpha (%)': apt_m['alpha'] * 12 * 100,
        'APT-Macro R²': apt_m['rsquared'],
        'APT-Stat Alpha (%)': apt_s['alpha'] * 12 * 100,
        'APT-Stat R²': apt_s['rsquared']
    })

comparison_df = pd.DataFrame(comparison_data)

print("\n" + "="*100)
print("MODEL COMPARISON: CAPM vs APT (Macro) vs APT (Statistical)")
print("="*100)
print(comparison_df.round(4).to_string(index=False))

# Factor loadings for one example (QQQ - tech-heavy)
print("\n" + "="*100)
print("DETAILED FACTOR LOADINGS: QQQ (Nasdaq ETF)")
print("="*100)

print("\nMacroeconomic Factors:")
qqq_macro = apt_macro_results['QQQ']
for factor_name, loading, tval in zip(macro_factors.columns, 
                                      qqq_macro['loadings'], 
                                      qqq_macro['tvalues']):
    sig = '***' if abs(tval) > 2.576 else ('**' if abs(tval) > 1.96 else ('*' if abs(tval) > 1.645 else ''))
    print(f"  {factor_name:>20}: {loading:>8.4f}  (t = {tval:>6.2f}) {sig}")

print("\nStatistical Factors (PCA):")
qqq_stat = apt_stat_results['QQQ']
for factor_name, loading, tval in zip([f'PC{i+1}' for i in range(5)],
                                     qqq_stat['loadings'],
                                     qqq_stat['tvalues']):
    sig = '***' if abs(tval) > 2.576 else ('**' if abs(tval) > 1.96 else ('*' if abs(tval) > 1.645 else ''))
    print(f"  {factor_name:>20}: {loading:>8.4f}  (t = {tval:>6.2f}) {sig}")

print("\n* p<0.10, ** p<0.05, *** p<0.01")

# Cross-sectional regression (estimate risk premiums λ)
def cross_sectional_regression(returns_avg, factor_loadings_matrix):
    """
    Second-pass cross-sectional regression: E[R] = λ0 + β·λ
    """
    X = sm.add_constant(factor_loadings_matrix)
    y = returns_avg
    
    model = sm.OLS(y, X)
    results = model.fit()
    
    return results

# Prepare data for cross-sectional regression (macro factors)
avg_returns = returns.mean() * 12 * 100  # Annualized %
loading_matrix_macro = pd.DataFrame({
    factor: [apt_macro_results[ticker]['loadings'][factor] for ticker in tickers]
    for factor in macro_factors.columns
}, index=tickers)

print("\n" + "="*100)
print("CROSS-SECTIONAL REGRESSION: Risk Premiums (λ)")
print("="*100)
cross_sect_results = cross_sectional_regression(avg_returns, loading_matrix_macro)
print(cross_sect_results.summary())

risk_premiums = cross_sect_results.params[1:]  # Exclude intercept
print("\nEstimated Risk Premiums (% per year):")
for factor, premium in risk_premiums.items():
    print(f"  {factor:>20}: {premium:>8.2f}%")

# Visualization
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Plot 1: R² comparison
models = ['CAPM', 'APT-Macro', 'APT-Stat']
r2_means = [
    comparison_df['CAPM R²'].mean(),
    comparison_df['APT-Macro R²'].mean(),
    comparison_df['APT-Stat R²'].mean()
]

bars = axes[0, 0].bar(models, r2_means, alpha=0.7, color=['blue', 'green', 'red'])
axes[0, 0].set_ylabel('Average R²')
axes[0, 0].set_title('Model Explanatory Power (Average R²)')
axes[0, 0].set_ylim([0, 1])
axes[0, 0].grid(axis='y', alpha=0.3)

for bar, val in zip(bars, r2_means):
    height = bar.get_height()
    axes[0, 0].text(bar.get_x() + bar.get_width()/2., height,
                   f'{val:.3f}', ha='center', va='bottom')

# Plot 2: Factor loadings heatmap (macro factors)
loading_heatmap = loading_matrix_macro.T
im = axes[0, 1].imshow(loading_heatmap, cmap='RdBu_r', aspect='auto', vmin=-2, vmax=2)

axes[0, 1].set_yticks(range(len(loading_heatmap.index)))
axes[0, 1].set_yticklabels(loading_heatmap.index)
axes[0, 1].set_xticks(range(len(loading_heatmap.columns)))
axes[0, 1].set_xticklabels(loading_heatmap.columns, rotation=45, ha='right')
axes[0, 1].set_title('Factor Loadings: Macro Factors')
plt.colorbar(im, ax=axes[0, 1])

# Plot 3: Alpha comparison across models
x = np.arange(len(comparison_df))
width = 0.25

bars1 = axes[1, 0].bar(x - width, comparison_df['CAPM Alpha (%)'], width, 
                       label='CAPM', alpha=0.8)
bars2 = axes[1, 0].bar(x, comparison_df['APT-Macro Alpha (%)'], width,
                       label='APT-Macro', alpha=0.8)
bars3 = axes[1, 0].bar(x + width, comparison_df['APT-Stat Alpha (%)'], width,
                       label='APT-Stat', alpha=0.8)

axes[1, 0].set_xticks(x)
axes[1, 0].set_xticklabels(comparison_df['Ticker'], rotation=45, ha='right')
axes[1, 0].set_ylabel('Alpha (% per year)')
axes[1, 0].set_title('Alpha Comparison Across Models')
axes[1, 0].axhline(0, color='black', linewidth=0.5)
axes[1, 0].legend()
axes[1, 0].grid(axis='y', alpha=0.3)

# Plot 4: Cumulative variance explained by PCs
cum_var = np.cumsum(pca_model.explained_variance_ratio_) * 100
axes[1, 1].plot(range(1, len(cum_var)+1), cum_var, marker='o', linewidth=2)
axes[1, 1].set_xlabel('Number of Principal Components')
axes[1, 1].set_ylabel('Cumulative Variance Explained (%)')
axes[1, 1].set_title('PCA: Cumulative Variance Explained')
axes[1, 1].grid(alpha=0.3)
axes[1, 1].set_xticks(range(1, len(cum_var)+1))

# Add percentage labels
for i, val in enumerate(cum_var):
    axes[1, 1].text(i+1, val, f'{val:.1f}%', ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()

# Arbitrage test
print("\n" + "="*100)
print("ARBITRAGE PORTFOLIO TEST")
print("="*100)
print("Concept: If two assets have similar factor exposures but different returns,")
print("         arbitrage opportunity exists (long high return, short low return)")

# Find assets with similar loadings on first 2 macro factors
loading_similarity = {}
for i, ticker1 in enumerate(tickers):
    for ticker2 in tickers[i+1:]:
        load1 = apt_macro_results[ticker1]['loadings'][:2]
        load2 = apt_macro_results[ticker2]['loadings'][:2]
        
        # Euclidean distance in loading space
        distance = np.sqrt(((load1 - load2)**2).sum())
        loading_similarity[(ticker1, ticker2)] = distance

# Find most similar pair
most_similar = min(loading_similarity, key=loading_similarity.get)
ticker_a, ticker_b = most_similar

print(f"\nMost similar factor exposures: {ticker_a} and {ticker_b}")
print(f"Loading distance: {loading_similarity[most_similar]:.4f}")

ret_a = avg_returns[ticker_a]
ret_b = avg_returns[ticker_b]

print(f"\nAverage Returns:")
print(f"  {ticker_a}: {ret_a:.2f}%")
print(f"  {ticker_b}: {ret_b:.2f}%")
print(f"  Difference: {abs(ret_a - ret_b):.2f}%")

if abs(ret_a - ret_b) > 2:  # Threshold for "significant" difference
    print(f"\nPotential arbitrage: Long {ticker_a if ret_a > ret_b else ticker_b}, "
          f"Short {ticker_b if ret_a > ret_b else ticker_a}")
else:
    print("\nNo clear arbitrage opportunity (returns similar given factor exposures)")

# Key insights
print("\n" + "="*100)
print("KEY INSIGHTS: ARBITRAGE PRICING THEORY")
print("="*100)
print("1. APT more flexible than CAPM (multiple risk factors vs single market factor)")
print("2. Statistical factors (PCA) capture latent risk sources in returns")
print("3. Macro factors provide economic interpretation of risk exposures")
print("4. APT typically increases R² by 5-20% over CAPM")
print("5. First principal component often resembles market factor (systematic risk)")
print("6. Factor loadings stable over time → useful for risk management")
print("7. APT doesn't specify factors → practitioner must choose (flexibility + ambiguity)")
print("8. Cross-sectional regression estimates risk premiums (price of factor risk)")

print("\n" + "="*100)
print("APT vs CAPM: Key Differences")
print("="*100)
print("• Assumptions: APT weaker (no market portfolio, no M-V utility required)")
print("• Factors: CAPM single (market), APT multiple (unspecified)")
print("• Derivation: CAPM equilibrium, APT arbitrage (no-arbitrage condition)")
print("• Empirics: APT better fit but requires factor identification")
print("• Testability: CAPM more specific, APT more ambiguous")
```

## 6. Challenge Round
Why is APT considered more general than CAPM?
- Weaker assumptions: No mean-variance utility, no market portfolio required
- Multiple risk sources: CAPM assumes all risk is market; APT allows many factors
- Arbitrage-based: Relies only on no-arbitrage, not equilibrium with homogeneous expectations
- Flexibility: Can incorporate macro factors, statistical factors, fundamental factors
- Realistic: Markets driven by multiple risks (growth, inflation, credit, etc.)

APT's fundamental problem:
- Factor ambiguity: Theory doesn't specify which factors (practitioners must choose)
- Testability: Hard to reject (can always add more factors to improve fit)
- Data mining risk: Selecting factors that worked historically (overfitting)
- Factor instability: Risk premiums change over time (non-stationary)
- Implementation: How many factors k? Trade-off between fit and parsimony

How to choose factors in practice?
- Economic theory: Macro variables affecting asset values (GDP, inflation, rates)
- Statistical methods: PCA on returns (extract latent factors)
- Prior empirical work: Fama-French factors (size, value, momentum)
- Market experience: Observed risk factors (credit spread, VIX, commodity prices)
- Cross-validation: Out-of-sample performance to avoid overfitting

## 7. Key References
- [Ross, S.A. (1976) "The Arbitrage Theory of Capital Asset Pricing"](https://www.sciencedirect.com/science/article/abs/pii/0022053176900466) - Original APT paper
- [Chen, Roll, Ross (1986) "Economic Forces and the Stock Market"](https://www.jstor.org/stable/2352710) - Macroeconomic factors
- [Burmeister, E. & McElroy, M. (1988) "Joint Estimation of Factor Sensitivities and Risk Premia"](https://www.jstor.org/stable/2328912)
- [Investopedia - Arbitrage Pricing Theory](https://www.investopedia.com/terms/a/apt.asp)

---
**Status:** Generalization of CAPM through multi-factor arbitrage framework | **Complements:** CAPM, Factor Models, PCA
